# DB 스터디 정리 19. 4. 10.

* 참고서
	- [Real MySQL] 위키북스, 이성욱 지음
***
# MySQL의 스토리지 엔진
- MySQL 엔진에서 처리를 수행하고 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담
- 스토리지 엔진은 여러 개이며 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기, 쓰기 작업은 정해진 스토리지 엔진이 담당
```
CREATE TABLE TAB_AUTO_INT2_INNODB (
  v1 varchar(10) NOT NULL,
  id2 INT NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (v1, id2),
  UNIQUE KEY (id2)
) ENGINE = InnoDB;
```

# InnoDB
- `InnoDB`는 MySQL의 엔진 중 거의 유일하게 레코드 기반 잠금 기능 제공
- 높은 동시성 처리 가능, 안정성 성능이 뛰어남

![InnoDB](drawio/InnoDB.jpg)

## InnoDB 스토리지 엔진의 특성
**1. `PK`에 의한 클러스터링**
- `InnoDB`의 모든 테이블은 기본적으로 `PK`를 기준으로 클러스터링 되어 저장됨 
- `PK`순서대로 디스크에 저장되고 인덱스 레인지 스캔이 빨리 처리됨

**2. 잠금이 필요없는 일관된 읽기 (Non-locking consistent read)**
- MVVC(Multi Version Concurrency Control) 기술을 이용해 락을 걸지 않고 읽기 작업 수행  
  [TODO: MVVC란?]
- 다른 트랜잭션이 가지고 있는 락을 기다리지도 않고 읽기 가능

**3. 외래 키 지원**
- `MyISAM`, `MEMORY` 스토리지 엔진에서는 사용 불가
- `InnoDB`에서의 외래 키는 부모, 자식 테이블의 해당 키가 모두 인덱스가 필요
- 변경 시 부모, 자식 테이블로 연쇄적으로 체크하므로 잠금이 전파되어 데드락 유발 가능성 높음

**4. 자동 데드락 감지**
- 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 감지됨  
  [TODO: 그래프 기반 데드락?]
- 감지된 데드락은 관련 트랜잭션 중 `ROLLBACK`이 가장 용이한(가장 작업이 덜 들어가는) 트랜잭션을 강제 종료
  
**5. 자동화된 장애 복구**
- MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지(Partial Write)등에 복구작업 자동 시행

## InnoDB 버퍼 풀
- DBMS는 `ACID`를 보장하기 위해 즉시 변경된 내용을 데이터 파일로 기록해야하지만 랜덤하게 디스크 I/O가 발생하므로 버퍼 사용
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 겸함  
- 디스크 데이터 파일의 이곳 저곳에 위치한 레코드를 변경하는 작업을 모아서 처리함으로써 랜덤한 디스크 작업 횟수 감소
- 백그라운드 작업의 기반이 되는 메모리 공간
- 디스크에 기록되지 않은 변경된 데이터를 가지고 있음
  - 더티 페이지 : 변경된 데이터가 포함된 페이지
  - `InnoDB`에서 주기적 혹은 특정 조건에 따라 체크 포인트 이벤트 발생
  - Write스레드가 필요한 만큼 더티 페이지를 디스크로 기록

## Undo 로그
- `UPDATE`, `DELETE` 같은 문장으로 데이터를 변경할 때 변경되기 전의 데이터를 보관하는 곳
- 두 가지 용도
  1. 트랜잭션의 `ROLLBACK`대비용 이전 데이터 보관
  2. 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용
    - 격리 수준 :  MySQL의 InnoDB는 기본적으로 `REPETABLE_READ`  
      동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때,  
      한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지 결정하는 기준  
    [TODO: 격리수준이란?]
- **주의** : 트랜잭션을 오래 열어둘 경우 `Undo log`에 막대한 양의 정보가 쌓이게 됨

## Insert 버퍼
- 데이터 파일을 변경할 뿐만 아니라 해당 테이블에 포함된 인덱스를 업데이트할 때 버퍼를 사용
- 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행
- 디스크로부터 읽어와서 업데이트 해야 하면 임시공간(`Insert Buffer`)에 저장 후 사용자에게 결과를 반환
- 결과 반환전에 중복 여부를 체크해야 하는 유니크 인덱스는 이를 사용할 수 없음
- 인서트 버퍼에 임시로 저장된 인덱스 레코드 조각은 백그라운드 스레드인 인서트 버퍼 머지 스레드에 의해 병합됨

## Redo 로그 및 로그 버퍼
- `InnoDB buffer pool`만으로는 `ACID`를 보장할 수 없기 때문에 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일 존재
- DBMS는 리두 로그와 버퍼링을 통해 한꺼번에 디스크에 변경된 내용 처리 가능
- 변경작업이 많은 DBMS 서버는 리두 로그 기록작업에 부하가 커서 `ACID`를 보장하는 수준에서 로그 버퍼를 이용해 버퍼링 처리

## MVCC(Multi Version Concurrency Control)
- 잠금을 사용하지 않는 일관된 읽기를 제공하기 위해 사용
- `InnoDB`는 `Undo Log`를 통해 구현
- Multi Version : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리됨
- ex) 격리수준 - READ_COMMITEED
```
CREATE TABLE member (
  m_id INT NOT NULL,
  m_name VARCHAR(20) NOT NULL,
  m_area VARCHAR(100) NOT NULL,
  PRIMARY KEY (m_id),
  INDEX ix_area (m_area)
);

INSERT INTO member (m_id, m_name, m_area) VALUES (12,'홍길동','서울');
COMMIT;
```
- 위 쿼리를 실행했을 때 데이터베이스의 모습은 다음과 같음
```
# 메모리 영역
  InnoDB 버퍼 풀
  +----------+------+--------+--------+
  | 관리 정보 | m_id | m_name | m_area |
  +----------+------+--------+--------+
  |    ...   |  12  |  홍길동 |  서울  | 
  +----------+------+--------+--------+

  Undo 로그
  - 이전에 아무 작업도 없어서 비어있다고 가정

# 디스크 영역
  +----------+------+--------+--------+
  | 관리 정보 | m_id | m_name | m_area |
  +----------+------+--------+--------+
  |    ...   |  12  |  홍길동 |  서울  | 
  +----------+------+--------+--------+
```
- 이때 다음의 `UPDATE` 쿼리를 실행하면
```
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```
```
# 메모리 영역
  InnoDB 버퍼 풀
  +----------+------+--------+--------+
  | 관리 정보 | m_id | m_name | m_area |
  +----------+------+--------+--------+
  |    ...   |  12  |  홍길동 |  경기  | <-
  +----------+------+--------+--------+

  Undo 로그
  +----------+------+--------+--------+
  | 관리 정보 | m_id | m_name | m_area |
  +----------+------+--------+--------+
  |    ...   |  12  |  홍길동 |  서울  | <-
  +----------+------+--------+--------+

# 디스크 영역
  +----------+------+--------+--------+
  | 관리 정보 | m_id | m_name | m_area |
  +----------+------+--------+--------+
  |    ...   |  12  |  홍길동 |   ???  | <-
  +----------+------+--------+--------+
```
- `UPDATE`문이 실행되면 `COMMIT`여부와 상관없이 `InnoDB buffer pool`은 새로운 값으로 갱신됨
- 디스크 데이터 파일에는 체크포인트나 Write 스레드에 의해 갱신 되어있을수도.. 아닐수도..  
  (InnoDB는 ACID를 보장하므로 동일한 상태라고 봐도 무방)
- **아직 `COMMIT` 혹은 `ROLLBACK` 명령이 오기 전**에 다른 커넥션에서 작업중인 레코드를 조회하면?
```
SELECT * FROM member WHERE m_Id = 12;
```
- 격리수준에 따라 다름
  - `READ_UNCOMMITTED` : 변경된 레코드 정보를 가져옴
  - `READ_COMMITTED`이상 : 변경되기 전 레코드(`Undo log`)를 가져옴
- 하나의 레코드에 대해 두 개의 버전이 존재하고 필요에 따라 데이터를 가져오는 버전이 다름
- `ROLLBACK` 실행시 해당 트랜잭션의 `Undo log`의 내용을 `InnoDB buffer pool`로 복구하고  
  `Undo log`영역의 내용은 해당 트랜잭션이 필요없을 때 삭제됨

## 잠금 없는 일관된 읽기 (Non-blocking consistent read)
- 격리 수준이 `REPEATABLE_READ`이하인 경우 순수한 `SELECT`작업은 다른 트랜잭션에 의한 잠금에 관계 없이 바로 실행됨
- 특정 사용자가 `COMMIT`, `ROLLBACK`을 시행하지 않았더라도 다른 사용자는 `SELECT` 가능!
***
# MyISAM

## 키 캐시
- `InnoDB`의 버퍼 풀과 비슷한 역할이지만 인덱스만 대상으로 작동
- 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할
- 키 캐시 히트율
```
Hit rate = 100 - (Key_records / Key_read_requests * 100)
```
- `Key_records` : 인덱스를 디스크에서 읽어들인 횟수
- `Key_read_requests` : 키 캐시로부터 인덱스를 읽은 횟수
