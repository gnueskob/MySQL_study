# 레디스 확장과 분산

- 서버 하나로는 성능 향상의 한계가 존재하기 때문에 여러개의 서버로 확장, 분산하여 사용

- 성능 향상방법
  - 스케일 업(scale up) : 단일 머신에 CPU, 디스크 등을 추가해서 성능을 향상하는 방법
  - 스케일 아웃(scale out) : 적절한 성능의 머신을 추가해서 전체적인 성능을 향상하는 방법
    - 소프트웨어가 지원하는 경우만 가능
- 대량 데이터 처리 방법
  - 데이터 파티셔닝(Data Partitioning)
    - 나은 성능, 가용성, 유지보수성을 위해 논리적 데이터들을 다수의 엔티티로 분할
    - 수직 파티셔닝
      - 하나의 엔티티에 저장된 데이터를 다수의 엔티티로 분할
      - ex) 한 테이블의 컬럼들을 다른 테이블로 분할하여 저장
    - 수평 파티셔닝(샤딩, Sharding)
      - 하나로 구성된 엔티티의 구조를 공유하는 복제 엔티티를 통해 데이터 분할
- 레디스의 스케일 아웃 방식의 성능 향상 기법 : 복제(`Replication`)와 샤딩(`Sharding`)

***

## 용어 정리

### `노드 (Node)`

- 하나의 레디스 서버를 의미

### `샤드 (Shard)`

- 두 개의 노드를 사용하여 데이터를 분할 저장 할 때의 각 노드

### `클러스터 (Cluster)`

- 여러 노드로 구성된 하나의 레디스 서버 집합
- 보통 마스터 노드와 여러개의 슬레이브 노드로 구성됨

***

## 복제

- 동일한 데이터를 다중의 노드에 중복하여 저장
- `Master-Slave` 복제의 개념 사용
- `Master` : 복제를 위한 데이터의 원본 역할
  - 기본적으로 마스터 노드에서 쓰기 연산을 수행
  - 슬레이브 노드의 정보가 필요 없음
  - 데이터 영구 저장기능을 복제본으로 넘겨 디스크 I/O를 수행하지 않게하기도 함
  - 어떤 이유에서든 자동으로 재시작하면 안됨
    - 재시작할 경우 빈 데이터 집합으로 시작된 마스터 노드를 슬레이브들이 복제함
- `Slave` (복제) : 마스터 노드에 데이터 복제 요청을 하고 데이터를 수신하여 동기화
  - 기본적으로 읽기 연산만 수행
  - 실시간으로 마스터 노드의 데이터를 복제
  - 슬레이브 노드 시작 시 마스터 노드에게 복제를 요청
  - 최초 복제 완료 이후 변경사항만 업데이트
  - 슬레이브 노드만이 마스터 노드의 위치 정보를 가지고 있음
  - 읽기 성능의 증대를 위해 사용
  - 복제본은 최근에 발생한 모든 데이터를 포함하며 마스터로 승격할 수 있음
- 마스터 노드에 연결된 복제본의 최소 개수를 요구해 데이터의 일관성 보장기능 향상
  - 복제본의 수에 따라 모든 복제본에게 마서트의 쓰기 작업을 전달해 줄수 없을수도 있음
  - 또한 복제에 따른 지연 현상(`lag`)이 나타남
  - 따라서 해당 기능은 마스터에 연결된 최소 복제본 개수를 보장하는 설정을 조절해야 함
  - `min-slaves-to-write`, `min-slaves-max-lag`
- `SLAVEOF NO ONE` : 현재 슬레이브를 마스터로 승격, 페일오버가 발생할 때 사용됨

```bash
# 기존 5555포트 마스터 노드가 오류로 종료되고
# 6666포트 슬레이브 노드가 마스터로 승격되며
# 7777포트의 마스터 노드 설정이 6666포트로 변경되는 과정
redis-cli -p 5555 DEBUG SEGFAULT
redis-cli -p 6666 SLAVEOF NO ONE
redis-cli -p 7777 SLAVEOF 127.0.0.1 6666
```

### 단일 복제

- 마스터 노드 1개, 슬레이브 노드 1개
- 마스터 노드 변경 발생시 실시간으로 슬레이브 노드에 데이터 변경사항 기록
- 레디스 클러스터는 동기화를 위해 쓰기 연산 명령을 슬레이브 노드로 전달

```text
+--------+       +--------+
| Master | ───── | Slave1 |
+--------+       +--------+
```

### 다중 복제

- 단일 복제 구조에 슬레이브 노드를 추가
  - 새로운 슬레이브 노드에 마스터 노드 정보를 추가하여 인스턴스를 시작
  - 마스터 노드를 재시작 할 필요 없음
- 쓰기 연산에 비하여 읽기 연산이 많은 서비스에 적합한 구조
- 슬레이브 노드가 많이 연결될 수록 마스터 노드의 복제를 위한 리소스 자원이 많이 소모됨
  - 네트워크 리소스 비용이 매우 큼

```text
                 +--------+  (read)
     ┌────────── | Slave1 | ──────── Client
     │           +--------+
     │
+--------+       +--------+  (read)
| Master | ───── | Slave2 | ──────── Client
+--------+       +--------+
  │  │
  │  │           +--------+  (read)
  │  └────────── | Slave3 | ──────── Client
  │              +--------+
  │ (write)
  │
Client
```

### 계층형 복제

- 마스터 노드와 슬레이브 노드 1이 1차로 동기화
- 슬레이브 노드 1을 다른 슬레이브 노드들이 복제
- 기본적으로 슬레이브 노드 1은 읽기,쓰기 연산을 제외한 복제만 하도록 설정함 (리소스 부족)

```text
                                 +--------+  (read)
                     ┌────────── | Slave2 | ──────── Client
                     │           +--------+
                     │
+--------+       +--------+      +--------+  (read)
| Master | ───── | Slave1 | ──── | Slave3 | ──────── Client
+--------+       +--------+      +--------+
    │                │
    │                │           +--------+  (read)
    │                └────────── | Slave4 | ──────── Client
    │                            +--------+
    │ (write)
    │
 Client
```

***

## 샤딩 / 파티셔닝

- 복제를 사용했을 경우보다 더 많은 데이터 저장 가능
- 쓰기 성능의 증대를 꾀할 수 있음
  - 각 서버가 존재하는 다중의 하드웨어에 쓰기 연산을 분산
- `수직 파티셔닝` : RDBMS에서의 테이블에 해당하는 정보를 노드별로 분할하여 저장
- `범위 지정 샤딩` : 키를 특정 범위 기준으로 분할하여 저장
  - ex) key 1~500: 노드 1 서버에 저장, key 501~1000: 노드 2 서버에 저장
- `해시 기반 샤딩` : 키를 해시 함수에 대입하여 결과값에 특정 연산을 가해 분할하여 저장
  - `일관된 해싱 (Consistent Hashing)`
  - ex) 샤드 번호 = md5('user:123') % 4

### 범위 파티셔닝

- 키의 범위를 정의하고 여러 레디스 인스턴스에 범위 내 키를 분산
- 데이터의 분포가 고르지 않은 경우가 발생할 수 있음
- 보통 레디스 인스턴스 개수에 따라 키의 범위 설정
  - 장비 목록의 변경이 일어날 경우 키의 범위 재설정, 데이터 재 분할이 필요

### 해시 파티셔닝

- 범위 파티셔닝보다 더 정교하고 고르지 않은 데이터 분포를 갖지도 않음
- 데이터를 저장할 레디스 인스턴스를 키의 해시값으로 지정
- 마찬가지로 레디스 인스턴스의 개수에 의존되기 때문에 장비 목록 변경이 어려움

### 미리 샤딩(Presharding)

- 해시 파티셔닝 기법에서 레디스 인스턴스 추가/삭제의 문제를 처리하는 방안
- 데이터를 많은 인스턴스로 미리 파티셔닝해 장비 목록의 개수를 절대 변하지 않게 함
  - 더 많은 레디스 인스턴스를 생성한 다음
  - 기존에 있는 서버를 재사용해 더 많은 인스턴스를 여러 포트에 바인딩하여 실행
- 레디스는 싱글 스레드 기반, 모든 자원을 활용하지 않음
  - 때문에 서버당 많은 레디스 인스턴스 실행가능하고 효율이 더 좋아짐
- 장비 목록의 개수가 변하지 않으므로 스케일 업 방식의 성능향상만 가능

### 일관적 해싱

- 해시 파티셔닝에서의 서버 노드 추가/삭제가 어려움
- 일관적 해싱은 해시 테이블의 크기가 변경될 때마다 키를 전달해주는 기법
  - 즉, 레디스의 서버 목록이 변경되면 일부 서버에 있는 데이터만 다시 매핑
  - `K`: 키의 개수, `n`: 서버 개수, 서버 목록 변경시 `K/n`개의 키가 다시 매핑됨
  - ex) 100개의 키와 4대의 서버 가정
    - 5번째 노드 추가시 평균 25키만 다시 매핑
- 각 레디스 키와 서버의 원에 여러 개의 점을 생성하는 것으로 구성됨
  - 주어진 키에 맞는 서버는 원(링, ring)에서 시계 방향으로 키에 가장 가까운 서버
  - `MD5`같은 해시 함수를 사용해 점을 생성

  ```text
  # 예시
  # 사용 가능한 서버 : server-1, server-2, server-3
  # 저장될 키 : key-1, key-2, key-3, key-4
  # 서버당 점의 개수: 1
  hash('server-1') = 3
  hash('server-2') = 7
  hash('server-3') = 11

  hash('key-1') = 3
  hash('key-2') = 4
  hash('key-3') = 8
  hash('key-4') = 12
  ```

  ```text
  # ring
                   key-4(server-1)
        server-3      │
              ＼      12
                11            1

          10                       2
                                       key-1(server-1)
                                      /
        9                            3 ─ server-1


          8                        4
         /                          ＼
      key-3     7             5      key-2(server02)
  (server-3)   /       6
          server-2

  ```

  - 링 구조
    - key-1: server-1, 1번 서버와 같은 값으로 매핑
    - key-2: server-2, 시계방향으로 가장 가까운 서버는 2
    - key-3: server-3
    - key-4: server-1
  - server-3이 제거될 경우 key-3은 server-1에 매핑됨
  - 무작위로 분포되기 때문에 서버 사이 키 분포가 균일하지 않을 수 있음
    - 때문에 원에 가상 서버 노드를 한 군데가 아닌 여러군데 분포시킴

- 실제 레디스 파티셔닝의 구현
  - `nutcracker` 트웸프록시 자동 샤딩

***

## 복제와 샤딩 혼합

- 레디스 클러스터는 복제와 샤딩을 혼합하여 구성할 수 있음

```text
┌────────────────Redis Cluster───────────────┐
│      shard 1                  shard 2      │
│  ┌─────────────┐          ┌─────────────┐  │
│  │ +---------+ │          │ +---------+ │  │
│  │ | 1, 2, 3 | │          │ | 4, 5, 6 | │  │
│  │ +---------+ │          │ +---------+ │  │
│  │ Master Node │          │ Master Node │  │
│  │             │          │             │  │
│  │ +---------+ │          │ +---------+ │  │
│  │ | 1, 2, 3 | │          │ | 4, 5, 6 | │  │
│  │ +---------+ │          │ +---------+ │  │
│  │  Slave Node │          │  Slave Node │  │
│  └─────────────┘          └─────────────┘  │
│                                            │
└────────────────────────────────────────────┘
```

***

## 태깅

- 키를 항상 동일한 서버에 저장하는 것을 보장
- 키 이름에 대한 규칙을 정하고 접두사, 또는 접미사를 기반으로 키 전달 방식을 정함
- 보통은 키 이름에 태그를 추가 (ex., `key_name:{tag}`)
- `SDIFF`, `SINTER`, `SUNION` 같은 명령들은 모든 키가 동일한 노드에 있어야함
  - 태깅을 통해 키가 동일한 노드에 저장되는 것을 보장
- 특정 태그를 포함하는 키는 해시값을 고정값으로 반환하게 해서 구현

***

## 레디스 데이터 베이스 (RDB)

- `.rdb`파일은 특정 시점의 레디스 데이터 바이너리
  - 레디스 인스턴스에 저장된 데이터를 표현
  - RDB파일 형태는 빠른 읽기/쓰기에 최적화됨
  - 성능을 높이기위해 파일 내부 구조는 레디스 인메모리 구조와 매우 비슷

- RDB 파일을 압축할 때 LZF 압축 사용
- 레디스 인스턴스를 완전히 복구하기위해선 하나의 RDB파일만으로 충분
- 주기적으로 RDB파일을 저장할 수 있기 때문에 백업 복구 기능이 준수
- `SAVE` 명령은 RDB를 즉시 생성하지만 스냅샷 과정에서 레디스 서버를 블록
  - `BGSAVE` 명령을 통해 자식 프로세스가 RDB를 생성하기 하는 것을 권장

## AOF (Append-only File)

- AOF를 활성화하면 레디스는 데이터 집합을 변경하는 커맨드를 받을 때마다 파일로 기록
  - AOF파일에 해당 커맨드를 모두 기록
  - AOF 설정 후 레디스를 재시작하면 이전의 모든 커맨드를 재실행하여 데이터 복구 가능
- `redis-check-aof` 툴
  - AOF가 불완전하거나 손상되는 경우 AOF파일을 쉽게 확인하고 고칠수 있게하는 명령

## RDB vs AOF

- 큰 데이터 집합을 복구할 때 복구 속도는 RDB가 빠름
  - 전체 데이터베이스에서 발생하는 모든 변경을 행할 필요가 없기 때문
  - 이전에 저장된 데이터만 로드하면 됨
- 두 기능은 다른 전략 방식이지만, 동시에 활성화할 수도 있음
  - 레디스는 시작시 RDB, AOF 파일 중 하나라도 존재하면 파일을 로드
  - 두 종류 파일 모두 존재시 AOF를 우선으로 로드

***

## 데이터 저장소 vs 캐시

- 레디스가 데이터 저장소로 쓰일 경우
  - 키를 항상 동일한 레디스 인스턴스에 매핑해야함
  - 데이터 저장소로 사용된다는 것은 레디스 서버가 변경되지 않는다는 것
  - 모든 키를 레디스 인스턴스 개수만큼 복제하고 질의시 원하는 복제 노드에서 처리
  - (14_Redis_클러스터.md 참조)
- 레디스가 캐시로 쓰일 때는 `consistent hashing` 사용