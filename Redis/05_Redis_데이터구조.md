# 레디스 데이터 구조와 명령어

- 레디스는 거대한 Key-Value 저장소로 거대한 Map 데이터 구조
- Map 데이터 구조 - 키 하나에 데이터형 하나가 저장되는 매우 단순한 구조

***

## 문자열 데이터

- 키 하나에 문자열 하나 저장 가능
- 저장 가능 최대 크기 512MB
- 인코딩된 문자열과 몇 가지 부가 정보가 포함된 구조체로 변환하여 저장(레디스 객체형)

## 추가 문자열 데이터 명령

- `setnx`, `msetnx`
  - 키와 값 pair를 저장하지만 키가 이미 존재할 경우 명령 자체를 실행하지 않음
  - `get` 명령과 `set`명령을 동시에 행하는 효과
  - 원자성 보장
  - 0: 저장 취소 / 1: 저장 성공

```redis
127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379> setnx k3 newv3
(integer) 0
127.0.0.1:6379> mget k1 k2 k3
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> msetnx k11 v11 k12 v12 k1 v1
(integer) 0
127.0.0.1:6379> mget k1 k11 k12
1) "v1"
2) (nil)
3) (nil)
```

- `getset`
  - 키가 이미 있더라도 새로운 값을 저장하고 이전에 저장된 값 반환

```redis
127.0.0.1:6379> mget k1 k2 k3
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> getset k1 newv1
"v1"
127.0.0.1:6379> getset k100 n100
(nil)
127.0.0.1:6379> mget k1 k100
1) "newv1"
2) "n100"
```

- `strlen`
  - 주어진 키에 저장된 문자열의 길이 조회
  - 키가 존재하지 않으면 0 반환

```redis
127.0.0.1:6379> strlen k1
(integer) 5
```

- 비트연산
  - `setbit`연산으로 생성되는 새로운 데이터는 `비트 offset/8 + 1`크기를 가짐 (bytes 단위)
  - offset은 가장 왼쪽부터 0으로 시작하며 추가되는 데이터는 우측으로 덧붙여서 증가함
  - On/Off 기능에서 엄청난 장점을 보임 (ex., 사용자 로그인 여부 with ID를 key값으로)

```redis
127.0.0.1:6379> info memory
# Memory
used_memory:1192672
used_memory_human:1.14M
...

# 9851254를 ID로 하는 사용자가 방문했음을 나타냄
127.0.0.1:6379> setbit login:20190508 9851254 1
(integer) 0

# 9851254개의 사용자를 나타낼 수 있으며 사용한 메모리는 2.1MB 정도 뿐
127.0.0.1:6379> info memory
# Memory
used_memory:1192672
used_memory_human:3.24M
```

***

## 해시 데이터

- 문자열 필드와 값으로 이루어진 MAP 구조
- `2^32-1`개의 필드와 값을 저장할 수 있음
- `hgetall`, `hkeys`, `hvals`를 제외한 해시 명령의 시간 복잡도는 `O(1)`
- 키 하ㅏ에 여러 개의 필드-값 쌍으로 구성됨

## 추가 해시 데이터 명령

- `hmset`
  - 주어진 필드와 값의 쌍을 해시데이터에 저장
  - 다중입력 가능
  - 키가 존재하지 않으면 새로운 해시 데이터 생성

- `hsetnx`
  - 주어진 필드가 존재하지 않을 때만 저장
  - 필드가 하나라도 존재할 경우 저장 자체를 취소

- `hmget`
  - 주어진 필드 목록을 주어진 키에서 조회

- `hlen`
  - 주어진 키에 저장된 필드의 개수 조회

- `hdel`
  - 주어진 키에 저장된 필드 제거

## 해시 데이터의 구조

- 레디스의 해시 데이터는 필드 수가 수백 개 정도일 때 매우 적은 양의 메모리에 저장 가능
- 데이터 저장에 구조체 사용
  - 실제 데이터가 저장된 위치를 가르키는 포인터와 부가정보로 구성
  - 레디스는 메모리 공간을 절약하기 위해 세가지 내부 저장구조만 사용
  - zipmap, ziplist, intset
- 내부 저장구조를 사용하면 CPU 사용량이 증가하므로 적당한 tradeoff 찾는 것이 관건

***

## 셋 데이터

- 중복을 허용하지 않는 집합 형태의 자료구조
- 정렬되어 있지 않음
- `2^32-1`개의 값 저장 가능
- 값이 저장될 때 중복 확인이 일어나며 `NX` 접미사 명령 불필요

## 추가 셋 데이터 명령

- `spop`
  - 주어진 키에 저장된 요소 중 임의의 요소를 제거하고 제거된 요소를 반환
  - 키가 없을시 (nil) 반환

- `smove`
  - 원본키에 저장된 요소를 대상키로 이동하고 이동 결과를 반환
  - 다중의 키에 저장된 요소를 대상으로 처리됨
  - 원자성 보장
  - 0: 원본키가 존재하지 않을 시
  - 1: 이동에 성공할 시

***

## 정렬된 셋 데이터

- 셋 데이터에 가중치를 추가하여 기본 오름차순으로 정렬된 상태의 구조
- `2^32-1`개 값 저장 가능
- 가중치로 정수 또는 배정밀도 부동소수점 가능
- 가중치를 인자로 사용하는 범위는 특수 표현식 사용 가능
  - 무한대 : +inf / -inf

***

## 리스트 데이터

- 저장 순서를 기억하는 데이터 구조로 중복을 허용
- `2^32-1`개 원소 저장 가능
- 이중 연결 리스트로 구현 (첫 번째, 마지막 요소 접근이 가장 빠름)
- 헤드, 테일에 바로 접근이 가능하여 스택, 큐로 많이 사용

***

## 키 관리

- 레디스에 저장된 키를 관리하는 명령
- 키의 삭제, 만료, 목록 조회, 직렬화, 역 직렬화 등

### 키의 삭제와 변경

- `del` : 레디스에 저장된 키와 데이터를 삭제하고 삭제된 키의 개수 반환
  - 키가 존재하지 않으면 0을 반환

| 명령     | del [key1] ([key2], ...) |
| :----- | :----------------------- |
| 최초 지원  | 1.0.0                    |
| 시간 복잡도 | O(1)                     |
| 응답     | <숫자 응답>, 삭제된 키의 수        |

- `rename` : 주어진 키의 이름을 변경하고 변경 결과 반환
  - 변경할 키가 이미 존재하면 0을 반환

| 명령     | rename [변경할 key] [변경될 key] |
| :----- | :------------------------- |
| 최초 지원  | 1.0.0                      |
| 시간 복잡도 | O(1)                       |
| 응답     | <숫자 응답>, OK                |

- `expire` : 지정된 키에 만료시간을 초 단위로 설정
  - 지정된 키가 존재하지 않거나 설정 실패시 0을 반환

| 명령     | expire [key] [time]      |
| :----- | :----------------------- |
| 최초 지원  | 1.0.0                    |
| 시간 복잡도 | O(1)                     |
| 응답     | <숫자 응답>, 1: 설정 성공, 0: 실패 |

- `ttl` : 지정된 키의 남은 만료시간을 초 단위로 조회
  - 만료시간이 지정되지 않았거나 키가 조냊하지 않으면 -1을 반환

| 명령     | ttl [key]        |
| :----- | :--------------- |
| 최초 지원  | 1.0.0            |
| 시간 복잡도 | O(1)             |
| 응답     | <숫자 응답>, 남은 만료시간 |

- `exists` : 지정된 키가 존재하는지 검사
  - 키가 존재하면 1, 존재하지 않으면 0을 반환

| 명령     | exists [key]            |
| :----- | :---------------------- |
| 최초 지원  | 1.0.0                   |
| 시간 복잡도 | O(1)                    |
| 응답     | <숫자 응답>, 1: 존재, 0: 존재 X |

- `expireat` : 만료시간을 유닉스 타임스탬프 시간으로 설정
  - 지정된 시간에 키가 만료됨

| 명령     | expireat [key] [UNIX_TIMESTAMP] |
| :----- | :------------------------------ |
| 최초 지원  | 1.2.0                           |
| 시간 복잡도 | O(1)                            |
| 응답     | <숫자 응답>, 1: 설정 완료, 0: 키가 없음     |

- `persist` : 키에 지정된 만료시간을 제거
  - 키가 존재하지 않거나 키에 지정된 만료시간이 없으면 0을 반환

| 명령     | persist [key]               |
| :----- | :-------------------------- |
| 최초 지원  | 2.2.0                       |
| 시간 복잡도 | O(1)                        |
| 응답     | <숫자 응답>, 1: 해제 완료, 0: 키가 없음 |

### 레디스의 키와 값의 관계

- 레디스 내부에서는 키를 위한 메모리 영역과 값을 위한 메모리 영역이 생성됨
- 키를 위한 메모리 영역에는 값이 저장된 메모리 영역의 포인터가 저장됨
- 같은 키로 다른 데이러틑 저장하는 명령이 입력되면 이전 값이 저장된 메모리는 해제됨

### 키 목록 조회

- `keys [pattern]` (02_Reids_다루기.md 참조)

***

## 레디스 키 설계

- 키 : NoSQL에서 데이터를 조회하기 위한 가장 기본적인 값
- NoSQL은 단일 키에 의해 데이터를 처리하기 때문에 RDBMS보다 정보를 구조적으로 저장하고 조회하지 못함
- NoSQL은 구조적, 중복 지양 방식을 희생하여 단순한 구조의 대량 데이터를 저장하고 조회하는데 특화
- NoSQL의 단순성을 해치지 않고 정보를 효율적으로 저장하려면 키 설계가 중요

### 관계형 데이터베이스 스키마로부터 키 설계

```SQL
SELECT * FROM user_profile WHERE user_id = 'kris';
```

```redis
127.0.0.1:6379> get user:profile:kris
```

- 레디스에서는 RDB와 달리 값에 부분정보가 포함되지 않고 키 정보에 부분정보가 포함됨
- 정보가 저장되는 위치가 달라짐
- RDB 테이블의 주 키를 조합하여 레디스의 키로 사용
- 하지만 데이터가 화면에 어떻게 출력될지에 따라서 다시 변경해야 할 수도 있음
  - 데이터의 저장이 홤녀 출력 데이터 구조에 따라서 바뀔 수 있음

### NoSQL의 저장 구조

- 사용자 테이블

| 사용자 번호 | 이름    |
| :----- | :---- |
| 252321 | kris  |
| 11452  | david |

- 작성글 테이블

| 사용자 번호 | 작성글 번호 | 제목     | 내용      |
| :----- | :----- | :----- | :------ |
| 11452  | 151    | 안녕하세요  | 날씨 좋네요  |
| 252321 | 156    | 반갑습니다  | 가입인사입니다 |
| 252321 | 157    | 오늘도... | ...     |

- 사용자 번호가 외래키로 설정되어있는 RDB

- 사용자 글 목록 키 설계 (Redis)

| 키                  | 값             |
| :----------------- | :------------ |
| posting:11452:151  | 안녕하세요/날씨 좋네요  |
| posting:252321:156 | 반갑습니다/가입인사입니다 |
| posting:252321:157 | 오늘도.../...    |

- NoSQL에서 관계를 표현하려면 관계 정보를 키에 포함시킬 수 있음
- 단, 사용자 번호와 포스팅 번호를 알고 있을 때만 조회가 가능하게 됨
